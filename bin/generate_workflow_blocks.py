#!/usr/bin/env python3
#  -*- coding: utf-8 -*-
"""
A script to create the stubs of Python scripts that will be used in a RMS workflow.
The stubs read the various files from disk (in this repo), so that the various workflows do not need to
be imported whenever there is a change in it, or in one of its dependencies.

This is called when running 'make init', and 'make generate-workflow-files'.

The resulting stubs are given in the 'workflow' directory (which again is inside the root of the repo)

Usage:
    ./bin/generate_workflow_blocks.py [--read-only] [--copy-to-rms-project <path to rms project>]
    ./generate_workflow_blocks.py <path to project folder> [--read-only] [--copy-to-rms-project <path to rms project>]
"""
from pathlib import Path
from shutil import copy
from sys import argv

import os


def run():
    root_path = get_root_path()
    workflows = get_workflows()
    for relative_path, items in workflows.items():
        for file_name in items:
            create_workflow_block_file(file_name, root_path, relative_path)

    for i in range(len(argv)):
        arg = argv[i]
        if arg == '--read-only':
            set_file_attributes(root_path)
        elif arg == '--copy-to-rms-project':
            project_location = Path(argv[i + 1]).absolute()
            workflow_dir = get_workflow_dir(root_path)
            add_ipl_scripts(root_path, project_location)
            for rms_name, workflow_name in get_rms_mapping().items():
                if workflow_name is not None:
                    _OS.copy(workflow_dir / rms_name, project_location / 'pythoncomp' / rms_name)


def get_workflow_block(file_name, root_path, relative_path):
    template = '''#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
A template for use in RMS workflow.
By using this, the files will be loaded at runtime, and there
is no longer a need to update / import the file into RMS.
This template refer to {relative_path}/{file_name}.py

DO NOT edit this file, unless you know exactly what you are doing!
"""

import roxar.rms

from importlib.machinery import SourceFileLoader
from pathlib import Path

import os
import sys
import platform


__author__ = "Sindre Nistad"
__email__ = "snis@equinor.com"
__version__ = "0.7.1"
__status__ = "Draft"

# Toggle whether the source files should be read from the plugin, or the git repo

# Utils
def _get_path_from_environment(environment_name, default_name):
    return Path(os.environ.get(environment_name, default_name))


# The path to the repository's root folder
root_path = _get_path_from_environment('APS_ROOT', '{root_path}')
release_location = Path('/project/res/APSGUI/releases')

# Add nrlib to PYTHONPATH
os_name, os_version, _ = platform.linux_distribution()
if os_name == 'Red Hat Enterprise Linux Workstation':
    # Assuming we are on RGS
    major = os_version[0]
    sys.path.insert(0, '/project/res/nrlib/nrlib-dist-RHEL{{}}-RMS{{}}'.format(major, roxar.rms.get_version()))

# Path to where the file below is located within the repository
relative_path = '{relative_path}'

# Name of Python file to be executed (excluding .py)
file_name = '{file_name}'

# The location of the folder which contains the RMS project
try:
    project_location_path = Path(project.filename).parent
except NameError:
    project_location_path = root_path  # or '.'

model_root = _get_path_from_environment('APS_RESOURCES', project_location_path)

# Add path to searchable path
sys.path.append(root_path)


# Generating necessary paths
def _load_module():
    absolute_path = '{{}}/{{}}/{{}}.py'.format(root_path, relative_path, file_name)
    module_path = relative_path.replace('/', '.') + '.' + file_name
    return SourceFileLoader(module_path, absolute_path).load_module()


# Getting the location of the necessary files
def _get_file(environ_name, default_name):
    return _get_path_from_environment(environ_name, prepend_absolute_path(default_name))


def _get_value(environ_name, default_value):
    return os.environ.get(environ_name, default_value)


def _undefined_file():
    return '_APS_NO_FILE'


def get_model_file():
    # Location of misc. specification files;
    # * APS.xml
    # * Create_redefined_blocked_facies_log.xml
    # * Create_prob_logs.xml
    # * bitmap2rms_model.xml
    path = _get_file('APS_MODEL_FILE', _undefined_file())
    if str(path).endswith(_undefined_file()):
        return None
    else:
        return path


def get_rms_data_file():
    # Location/name of rms_project_data_for_APS_gui.xml
    return _get_file('APS_RMS_DATA_FILE', 'rms_project_data_for_APS_gui.xml')


def get_global_include_file():
    # Location/name of test_global_include.ipl
    return _get_file('APS_GLOBAL_INCLUDE_FILE', 'test_global_include.ipl')


def get_fmu_variables_file():
    return _get_file('APS_FMU_VARIABLES_FILE', 'examples/FMU_selected_variables.dat')


def get_tagged_variables_file():
    return _get_file('APS_FMU_TAGS_FILE', 'examples/FMU_tagged_variables.dat')


def get_tag_all_variables():
    return _get_value('APS_TAG_ALL_VARIABLES', False)


def get_output_fmu_tagged_model_file():
    return _get_file('APS_OUTPUT_FMU_MODEL_FILE', 'APS_with_FMU_tags.xml')


def get_write_logfile():
    return _get_value('APS_WRITE_LOG_FILE', True)


def get_input_directory():
    path = Path(os.environ.get('APS_INPUT_DIRECTORY', 'tmp_gauss_sim'))
    if not path.is_absolute():
        path = model_root / path
    return path


def get_debug_level():
    # How verbose it should be
    return _get_value('APS_DEBUG_LEVEL', 0)


def prepend_absolute_path(file):
    return model_root / file


# Keywords to pass along to the various modules
kwargs = {{
    # Legal values: 0..4 (0 is off, while 4 is very verbose)
    'debug_level': get_debug_level(),
    # Misc. flags
    'use_prefix_as_fallback': True,
    'write_log_file': get_write_logfile(),
    # Prefix for the location of model files (if absolute paths are not given)
    'prefix': root_path,
    # APS model file
    'model_file_name': get_model_file(),
    'output_rms_data_file': get_rms_data_file(),
    'global_ipl_file': get_global_include_file(),
    'output_model_file': get_output_fmu_tagged_model_file(),
    # FMU parameters
    'tagged_variables_file': get_tagged_variables_file(),
    'tag_all_variables': get_tag_all_variables(),
    'fmu_variables_file': get_fmu_variables_file(),
    'input_directory': get_input_directory(),
}}

# Stringify Paths
for key, value in kwargs.items():
    if isinstance(value, Path):
        kwargs[key] = str(value.absolute())

module = _load_module()
module.run(roxar, project, **kwargs)
'''

    return template.format(file_name=file_name, root_path=root_path.absolute(), relative_path=relative_path)


def get_root_path():
    if len(argv) == 1 or argv[1] in ['--read-only',  '--copy-to-rms-project']:
        return Path('.').absolute()
    else:
        return Path(argv[1])


def get_workflows():
    return {
        'bin': [
            'updateAPSModelFromFMU',
            'updateAPSModelFromUncertaintyTable',
            'createProbabilityLogs',
            'createRedefinedBlockedFaciesLog',
        ],
        'depricated': [
        ],
        'src/rms_jobs': [
            'APS_main',
            'APS_simulate_gauss_multiprocessing',
            'APS_simulate_gauss_singleprocessing',
            'defineFaciesProbMapDepTrend',
            'defineFaciesProbTrend',
            'APS_normalize_prob_cubes',
            'APS_set_seed_file_for_multiprocessing_workflow',
            'bitmap2rms',
            'Compare_files_with_uncertainty_parameters',
        ],
        'src/algorithms': [
            'setupFMUtags',
        ],
        'src/utils': [
            'testPreview',
        ],
        'src/utils/roxar': [
            'APS_update_gauss_rms',
            'getGridModelAttributes',
            'compare_files',
        ],
    }


def get_rms_mapping():
    return {
        'APS_truncate': 'APS_main.py',
        'Test_APS': None,
        'APS_test_preview': 'testPreview.py',
        'APS_update_from_FMU': 'updateAPSModelFromFMU.py',
        'APS_define_depositional_trend': 'defineFaciesProbMapDepTrend.py',
        'APS_simulate_gauss_fields_multiprocessing': 'APS_simulate_gauss_multiprocessing.py',
        'APS_import_simulated_gauss_fields': 'APS_update_gauss_rms.py',
        'APS_simulate_gauss_fields': 'APS_simulate_gauss_singleprocessing.py',
        'APS_export_grid_model_info': 'getGridModelAttributes.py',
        'test_welldata_api': None,
        'test_gridmodel_parameters_api': None,
        'Example_discrete_parameter_info': None,
        'Example_zone_and_region_parameter': None,
        'APS_update_from_rms_uncertainty_table': 'updateAPSModelFromUncertaintyTable.py',
        'Compare_files_with_uncertainty_parameters': 'Compare_files_with_uncertainty_parameters.py',
        'APS_define_probability_logs': 'createProbabilityLogs.py',
        'APS_merge_facies_logs': 'createRedefinedBlockedFaciesLog.py',
        'APS_create_FMU_tags': 'setupFMUtags.py',
        'APS_define_probability_trends': 'defineFaciesProbTrend.py',
        'Compare_files_updated_with_FMU_parameters': None,
        'APS_normalize_prob_cubes': 'APS_normalize_prob_cubes.py',
        'APS_bitmap2rms': 'bitmap2rms.py',
        'APS_set_seed_file_for_multiprocessing_workflow': 'APS_set_seed_file_for_multiprocessing_workflow.py',
        'APS_compare_files': 'compare_files.py',
    }


def get_file_mapping():
    return {file: rms_name for rms_name, file in get_rms_mapping().items() if file}


def get_workflow_dir(root_path):
    workflow_dir = root_path / 'workflow'
    if not _OS.exists(workflow_dir):
        _OS.makedirs(workflow_dir.absolute())
    return workflow_dir


def create_workflow_block_file(file_name, root_path, relative_path):
    script_name = file_name + '.py'
    script_path = root_path / relative_path / script_name
    assert _OS.exists(script_path), "the file '{}' does not exist".format(script_path)
    workflow_dir = get_workflow_dir(root_path)
    workflow_path = str(workflow_dir / get_file_mapping()[script_name])
    workflow_block = get_workflow_block(file_name, root_path, relative_path)
    with open(workflow_path, 'w') as f:
        f.write(workflow_block)


def get_ipl_scripts(root_path):
    ipl_dir = root_path / 'src/IPL'
    return [ipl_dir / ipl_script for ipl_script in _OS.listdir(ipl_dir)]


def add_ipl_scripts(root_path, project_location):
    ipl_scripts = get_ipl_scripts(root_path)
    ipl_dir = project_location / 'commandscomp'
    for ipl_script in ipl_scripts:
        _OS.copy(ipl_script.absolute(), ipl_dir.absolute())


def set_file_attributes(root_path):
    workflow_path = get_workflow_dir(root_path).absolute()
    _set_read_only(workflow_path)


def _set_read_only(workflow_path):
    _OS.chmod(workflow_path)
    for _, _, files in _OS.walk(workflow_path):
        for file in files:
            _OS.chmod(workflow_path / file)


class _OS:
    @staticmethod
    def walk(path):
        return os.walk(_OS._get_absolute_path(path))

    @staticmethod
    def copy(source, target):
        copy(_OS._get_absolute_path(source), _OS._get_absolute_path(target))

    @staticmethod
    def exists(path):
        return _OS._exec(path, os.path.exists)

    @staticmethod
    def listdir(path):
        return _OS._exec(path, os.listdir)

    @staticmethod
    def chmod(path):
        _OS._exec(path, lambda p: os.chmod(p, 0o555))

    @staticmethod
    def makedirs(path):
        _OS._exec(path, os.makedirs)

    @staticmethod
    def _exec(path, fun):
        return fun(_OS._get_absolute_path(path))

    @staticmethod
    def _get_absolute_path(path):
        return str(path.absolute())


if __name__ == '__main__':
    run()
