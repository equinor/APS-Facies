#!/usr/bin/env python3
#  -*- coding: utf-8 -*-
"""
A script to create the stubs of Python scripts that will be used in a RMS workflow.
The stubs read the various files from disk (in this repo), so that the various workflows do not need to
be imported whenever there is a change in it, or in one of its dependencies.

This is called when running 'make init', and 'make generate-workflow-files'.

The resulting stubs are given in the 'workflow' directory (which again is inside the root of the repo)

Usage:
    ./bin/generate_workflow_blocks.py [--read-only] [--use-temporary-workflow-dir] [--suffix <endig to all files>] [--copy-to-rms-project <path to rms project>]
    ./generate_workflow_blocks.py <path to project folder> [--read-only] [--use-temporary-workflow-dir] [--suffix <endig to all files>] [--copy-to-rms-project <path to rms project>]

The suffix MUST include a dot if a file ending is intended.
"""
import random
import string
from pathlib import Path
from shutil import copy
from sys import argv
from tempfile import gettempdir

import os
from typing import Dict, List, Optional, Tuple, Iterator, Iterable, Callable, Any


def run() -> None:
    use_plugin_dir = False
    if '--normal-install' in argv:
        # Install from unpacked plugin directory
        print("Standard install")
        use_plugin_dir = True
    else:
        # Install from APS repo bin directory
        print("Full install")

    workflows = get_workflows(use_plugin_dir=use_plugin_dir)
    root_path = get_root_path(use_plugin_dir=use_plugin_dir)
    toolbox_version = get_toolbox_version()
    use_temporary = '--use-temporary-workflow-dir' in argv
    salt = None
    if use_temporary:
        salt = get_random_name()

    suffix = ''
    if '--suffix' in argv:
        suffix = argv[argv.index('--suffix') + 1]

    for relative_path, items in workflows.items():
        for file_name in items:
            create_workflow_block_file(file_name, root_path, relative_path,
                toolbox_version, use_temporary, salt, suffix, use_plugin_dir=use_plugin_dir)

    for i in range(len(argv)):
        arg = argv[i]
        if arg == '--read-only':
            set_file_attributes(root_path)
        elif arg == '--copy-to-rms-project':
            project_location = Path(argv[i + 1]).absolute()
            workflow_dir = get_workflow_dir(root_path, use_temporary, salt)
            add_ipl_scripts(root_path, project_location)
            for rms_name, workflow_name in get_rms_mapping(suffix).items():
                if workflow_name is not None:
                    _OS.copy(workflow_dir / rms_name, project_location / 'pythoncomp' / rms_name)


def get_workflow_block(file_name: str, relative_path: str, toolbox_version: str) -> str:
    template = '''#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
A template for use in RMS workflow.
By using this, the files will be loaded at runtime, and there
is no longer a need to update / import the file into RMS.
This template refers to {relative_path}/{file_name}.py

DO NOT edit this file, unless you know exactly what you are doing!
"""

import roxar.rms

from zipfile import ZipFile
from importlib import import_module
from pathlib import Path

import os
import sys
import shutil


__author__ = "Sindre Nistad"
__email__ = "snis@equinor.com"
__version__ = "{toolbox_version}"
__status__ = "Draft"

# Toggle whether the source files should be read from the plugin, or the git repo


# Define all used environment variables
APS_ROOT                  = 'APS_ROOT'
APS_RESOURCES             = 'APS_RESOURCES'
APS_MODEL_FILE            = 'APS_MODEL_FILE'
APS_MODEL_FILE_FORMAT     = 'APS_MODEL_FILE_FORMAT'
APS_RMS_DATA_FILE         = 'APS_RMS_DATA_FILE'
APS_GLOBAL_VARIABLES_FILE = 'APS_GLOBAL_VARIABLES_FILE'
APS_FMU_VARIABLES_FILE    = 'APS_FMU_VARIABLES_FILE'
APS_FMU_TAGS_FILE         = 'APS_FMU_TAGS_FILE'
APS_FMU_FILE_FORMAT       = 'APS_FMU_FILE_FORMAT'
APS_TAG_ALL_VARIABLES     = 'APS_TAG_ALL_VARIABLES'
APS_OUTPUT_FMU_MODEL_FILE = 'APS_OUTPUT_FMU_MODEL_FILE'
APS_WRITE_LOG_FILE        = 'APS_WRITE_LOG_FILE'
APS_INPUT_DIRECTORY       = 'APS_INPUT_DIRECTORY'
APS_DEBUG_LEVEL           = 'APS_DEBUG_LEVEL'
APS_GRF_TRANSFORM         = 'APS_GRF_TRANSFORM'
RMS_PLUGINS_LIBRARY       = 'RMS_PLUGINS_LIBRARY'
APS_TRACEBACK             = 'APS_TRACEBACK'


# Utils
def _get_path_from_environment(environment_name, default_name):
    paths = os.environ.get(environment_name, default_name)
    if isinstance(paths, str):
        return Path(paths.split(':')[0])
    return paths


def _get_value(environ_name, default_value):
    return os.environ.get(environ_name, default_value)

# Check if traceback is to be turned off
def excepthook(type, value, traceback):
    print(f"ERROR:")
    print(f"Type:  {{type.__name__}}")
    print(f"{{value}}")

def get_traceback_setting():
    # Traceback setting on/off if errors are raised
    value = _get_value(APS_TRACEBACK, False)
    if isinstance(value, bool):
        return value
    if value == '0' or value == 'False':
        return False
    return True

if get_traceback_setting():
    # Use default traceback
    sys.excepthook = sys.__excepthook__
else:
    # Turn off traceback
    sys.excepthook = excepthook

# The path to the repository's root folder
temp_dir = Path(roxar.rms.get_tmp_dir())
root_path = _get_path_from_environment(APS_ROOT, temp_dir / 'aps_gui' / 'pydist')
print(f"Root path: {{root_path}}")
print(f"Version of this script: {{__version__}}")
release_location = _get_path_from_environment(RMS_PLUGINS_LIBRARY, '/project/res/APSGUI/releases/stable')

# Path to where the file below is located within the repository
relative_path = '{relative_path}'

# Name of Python file to be executed (excluding .py)
file_name = '{file_name}'

# The location of the folder that contains the RMS project
try:
    project_location_path = Path(project.filename).parent
except NameError:
    project_location_path = root_path  # or '.'

# Where RMS is started from
start_path = Path('.').absolute()


def get_plugin_dir():
    version = roxar.rms.get_version()
    try:
        major, minor, patch = version.split('.')
        if minor == '0':
            rms_version = major
        else:
            rms_version = major + '.' + minor
    except ValueError:
        rms_version = version
    preferences = Path(Path.home() / '.roxar/rms-{{}}/preferences.master'.format(rms_version))
    if not preferences.exists():
        preferences = Path(Path.home() / '.config/AspenTech/RMS/{{}}/preferences.master'.format(rms_version))
        if not preferences.exists():
            raise IOError(f'Can not find file {{preferences}} with RMS user preferences')
    with open(preferences, encoding='utf-8') as f:
        lines = f.readlines()

    plugin_dir = release_location
    for line in lines:
        if line.startswith('jobplugindir'):
            new_location = line.split('=')[1].strip()
            if new_location:
                # The location may be set to an empty string
                plugin_dir = Path(new_location)
    return plugin_dir


def get_current_plugin_path():
    # TODO: Get the version RMS is _actually_ using
    #       That is, RMS _could_ be using a different version than what is _should_ (this happens occasionally)
    paths = [p.absolute() for p in get_plugin_dir().glob('aps_gui*')]
    version_data = []
    current_path = None
    #File format: directorypath/aps_gui.major.minor.patch.plugin   or
    #             directorypath/aps_gui.major.minor.patch.timestamp.plugin
    #Example /project/res/APSGUI/releases/aps_gui.1.3.10.221991918.plugin  or
    #        /project/res/APSGUI/releases/stable/aps_gui.1.3.10.plugin
    for path in paths:
        if not path.suffix:
            raise IOError(
                f"Found file {{str(path)}}. "
                f"Expecting plugin of the form aps_gui.major.minor.patch.plugin "
                f"or aps_gui.major.minor.patch.timestamp.plugin"
            )
        last_suffix = path.suffixes[-1]
        if last_suffix == '.plugin':
            suffixes = [int(suffix.strip('.')) for suffix in path.suffixes[:-1]]
            if len(suffixes) == 3:
                # That is, major, minor, patch
                suffixes.append(float('inf'))
            version_data.append((path, tuple(suffixes)))
    if version_data:
        # Sort on version numbering
        version_data.sort(key=lambda x: (x[-1]))
        current_path = version_data[-1][0]
    text = 'Plugin_path: ' + str(current_path)
    print(text)
    return current_path


def stringify_path(path):
    return str(path.absolute())


def extract_plugin():
    extracted = temp_dir / 'aps_gui'
    def unzip():
        with ZipFile(str(get_current_plugin_path())) as zf:
            zf.extractall(path=temp_dir)

    if not extracted.exists():
        unzip()
    else:
        # Check that the version of the extracted plugin is the same as the expected version
        with open(extracted / 'VERSION', encoding='utf-8') as f:
            for line in f.readlines():
                if line:
                    extracted_version = line.strip()
                    break
        if not get_current_plugin_path().match('*' + extracted_version + '*'):
            # A refresh is required
            shutil.rmtree(extracted, ignore_errors=True)
            unzip()


model_root = _get_path_from_environment(APS_RESOURCES, project_location_path)

if APS_ROOT not in os.environ:
    # Add the path to searchable path
    # Assumed that the plugin should not be used, if 'APS_ROOT' is set

    extract_plugin()
    sys.path.insert(0, stringify_path(root_path))

    # Check that the STUB_VERSION in the plugin is the same as in current file
    toolbox_version_path = root_path / ".." / "STUB_VERSION"
    version_error = False
    if toolbox_version_path.is_file():
        with open(toolbox_version_path, "r", encoding='utf-8') as f:
            for line in f.readlines():
                if line:
                    toolbox_version_in_plugin = line.strip()
                    break

        if toolbox_version_in_plugin != __version__:
            version_error = True
            print(f"The APS plugin version need helpscript version: {{toolbox_version_in_plugin}}")
            print(f"The current help script has version: {{__version__}}")
    else:
        version_error = True

    if version_error:
        print("The APS help scripts in your RMS workflow must be updated.")
        env_key = "APS_TOOLBOX_PATH"
        if env_key in os.environ:
            install_path = str(os.environ[env_key])
            print("You can update the help script by re-loading the python code from the directory:")
            print(f"{{install_path}}/aps_workflows")
            print("NOTE: When selecting file, choose 'All files (*)' and not 'Python files (*.py)' files since the help scripts don't have '.py' extension")
        raise ValueError("Help script version is not up to date with the APS plugin version")


# Generating necessary paths
def _load_module():
    module_path = relative_path.replace('/', '.') + '.' + file_name
    print(f"Module used: {{module_path}}")
    return import_module(module_path)


# Getting the location of the necessary files
def _get_file(environ_name, default_name):
    return _get_path_from_environment(environ_name, prepend_absolute_path(default_name))



def _undefined_file():
    return '_APS_NO_FILE'


def get_model_file():
    # Location of misc. specification files;
    # * APS.xml
    # * Create_redefined_blocked_facies_log.xml
    # * Create_prob_logs.xml
    # * bitmap2rms_model.xml
    path = _get_file(APS_MODEL_FILE, _undefined_file())
    if str(path).endswith(_undefined_file()):
        return None
    else:
        return path

def get_model_file_format():
    return _get_value(APS_MODEL_FILE_FORMAT, 'both')

def get_rms_data_file():
    # Location/name of rms_project_data_for_APS_gui.xml
    return _get_file(APS_RMS_DATA_FILE, 'rms_project_data_for_APS_gui.xml')


def get_global_variables_file():
    # Location/name of global_variables.yml
    return _get_file(APS_GLOBAL_VARIABLES_FILE, '../../fmuconfig/output/global_variables.yml')


def get_fmu_variables_file():
    return _get_file(APS_FMU_VARIABLES_FILE, 'examples/FMU_selected_variables.dat')


def get_tagged_variables_file():
    return _get_file(APS_FMU_TAGS_FILE, 'examples/FMU_tagged_variables.dat')


def get_tag_all_variables():
    return _get_value(APS_TAG_ALL_VARIABLES, False)


def get_output_fmu_tagged_model_file():
    return _get_file(APS_OUTPUT_FMU_MODEL_FILE, 'APS_modified.xml')


def get_write_logfile():
    return _get_value(APS_WRITE_LOG_FILE, True)


def get_input_directory():
    path = Path(os.environ.get(APS_INPUT_DIRECTORY, 'tmp_gauss_sim'))
    if not path.is_absolute():
        path = model_root / path
    return path


def get_debug_level():
    # How verbose it should be. Default is to read it from model file keyword.
    return _get_value(APS_DEBUG_LEVEL, -1)

def get_transform_type():
    # Which type of transformation to use for GRF's
    # (Default = EMPIRIC, Cumulative normal distribution function = CUMNORM)
    return _get_value(APS_GRF_TRANSFORM, 0)

def prepend_absolute_path(file):
    return start_path / file


def get_fmu_file_format():
    return _get_file(APS_FMU_FILE_FORMAT, 'grdecl')


# Keywords to pass along to the various modules
kwargs = {{
    'roxar': roxar,
    'project': project,
    # Legal values: 0..4 (0 is off, while 4 is very verbose)
    'debug_level': get_debug_level(),
    # Misc. flags
    'use_prefix_as_fallback': True,
    'write_log_file': get_write_logfile(),
    # Prefix for the location of model files (if absolute paths are not given)
    'prefix': root_path,
    # APS model file
    'model_file_name': get_model_file(),
    'model_file_format': get_model_file_format(),
    'output_rms_data_file': get_rms_data_file(),
    'global_variables_file': get_global_variables_file(),
    'output_model_file': get_output_fmu_tagged_model_file(),
    # FMU parameters
    'tagged_variables_file': get_tagged_variables_file(),
    'tag_all_variables': get_tag_all_variables(),
    'fmu_variables_file': get_fmu_variables_file(),
    'input_directory': get_input_directory(),
    'field_file_format': get_fmu_file_format(),
    # GRF transformation
    'transformation_type': get_transform_type(),
    'traceback': get_traceback_setting(),
}}

# Stringify Paths
for key, value in kwargs.items():
    if isinstance(value, Path):
        kwargs[key] = stringify_path(value)

module = _load_module()
module.run(**kwargs)

# Reset traceback to default
if file_name != 'turn_off_traceback':
    sys.excepthook = sys.__excepthook__
'''

    return template.format(
        file_name=file_name,
        relative_path=relative_path,
        toolbox_version=toolbox_version,
    )


def get_root_path(use_plugin_dir=False) -> Path:
    legal_options = ['--read-only', '--copy-to-rms-project', '--use-temporary-workflow-dir', '--normal-install']
    if not use_plugin_dir:
        if len(argv) == 1 or argv[1] in legal_options:
            path = '.'
            return Path(path).absolute()
        else:
            return Path(argv[1])
    else:
        if len(argv) == 1 or argv[1] in legal_options:
            path = Path('.') / 'aps_gui' / 'pydist'
            print(path)
            return path.absolute()
        else:
            return Path(argv[1])


def get_toolbox_version() -> str:
    file_paths = ["bin/STUB_VERSION", "aps_gui/STUB_VERSION" ]
    version = None
    for file_path in file_paths:
        if Path(file_path).exists():
            with open(file_path, "r", encoding='utf-8') as file:
                for line in file.readlines():
                    if line:
                        version = line.strip()
                        break
    if not version:
        raise IOError(
            "Did not find the file: STUB_VERSION.\n"
            "Run from top directory of source code repo  (bin/generate_workflow_blocks.py)\n"
            "or run from directory for unpacked version of the plugin (aps_gui/generate_workflow_blocks.py --normal-install).")
    return version


def get_workflows(use_plugin_dir: bool = False) -> Dict[str, List[str]]:
    return {
        'bin': [],
        'depricated': [],
        'aps/rms_jobs': [
            'APS_main',
            'APS_simulate_gauss_multiprocessing',
            'APS_simulate_gauss_singleprocessing',
            'defineFaciesProbMapDepTrend',
            'defineFaciesProbTrend',
            'APS_normalize_prob_cubes',
            'APS_set_seed_file_for_multiprocessing_workflow',
            'bitmap2rms',
            'Compare_files_with_uncertainty_parameters',
            'updateAPSModelFromFMU',
            'updateAPSModelFromUncertaintyTable',
            'createProbabilityLogs',
            'createRedefinedBlockedFaciesLog',
            'copy_rms_param_to_fmu_grid',
            'test_jobs_and_workflow',
            'turn_off_traceback',
            'turn_on_traceback',
            'APS_redefine_zone_models',
        ],
        'aps/algorithms': [
            'setupFMUtags',
        ],
        'aps/utils': [
            'testPreview',
        ],
        'aps/utils/roxar': [
            'APS_update_gauss_rms',
            'getGridModelAttributes',
            'compare_files',
        ],
    }


def get_rms_mapping(suffix: str = '') -> Dict[str, Optional[str]]:
    return {
        rms_name + suffix: stub
        for rms_name, stub in [
            ('APS_truncate', 'APS_main.py'),
            ('Test_APS', None),
            ('APS_test_preview', 'testPreview.py'),
            ('APS_update_from_FMU', 'updateAPSModelFromFMU.py'),
            ('APS_define_depositional_trend', 'defineFaciesProbMapDepTrend.py'),
            ('APS_simulate_gauss_fields_multiprocessing', 'APS_simulate_gauss_multiprocessing.py'),
            ('APS_import_simulated_gauss_fields', 'APS_update_gauss_rms.py'),
            ('APS_simulate_gauss_fields', 'APS_simulate_gauss_singleprocessing.py'),
            ('APS_export_grid_model_info', 'getGridModelAttributes.py'),
            ('test_welldata_api', None),
            ('test_gridmodel_parameters_api', None),
            ('Example_discrete_parameter_info', None),
            ('Example_zone_and_region_parameter', None),
            ('APS_update_from_rms_uncertainty_table', 'updateAPSModelFromUncertaintyTable.py'),
            ('Compare_files_with_uncertainty_parameters', 'Compare_files_with_uncertainty_parameters.py'),
            ('APS_define_probability_logs', 'createProbabilityLogs.py'),
            ('APS_merge_facies_logs', 'createRedefinedBlockedFaciesLog.py'),
            ('APS_create_FMU_tags', 'setupFMUtags.py'),
            ('APS_define_probability_trends', 'defineFaciesProbTrend.py'),
            ('Compare_files_updated_with_FMU_parameters', None),
            ('APS_normalize_prob_cubes', 'APS_normalize_prob_cubes.py'),
            ('APS_bitmap2rms', 'bitmap2rms.py'),
            ('APS_set_seed_file_for_multiprocessing_workflow', 'APS_set_seed_file_for_multiprocessing_workflow.py'),
            ('APS_compare_files', 'compare_files.py'),
            ('APS_resample_to_ertbox', 'copy_rms_param_to_fmu_grid.py'),
            ('APS_run_workflow', 'test_jobs_and_workflow.py'),
            ('Turn_off_traceback', 'turn_off_traceback.py'),
            ('Turn_on_traceback', 'turn_on_traceback.py'),
            ('APS_redefine_zone_models', 'APS_redefine_zone_models.py'),
        ]
    }


def get_random_name(length=5):
    characters = string.ascii_letters + string.digits
    return ''.join([random.choice(characters) for _ in range(length)])


def get_file_mapping(suffix: str = '') -> Dict[str, str]:
    return {file: rms_name for rms_name, file in get_rms_mapping(suffix).items() if file}


def get_workflow_dir(
        root_path: Path,
        use_temporary: Optional[bool] = False,
        salt: Optional[str] = None,
) -> Path:
    if use_temporary:
        root_path = Path(gettempdir())
    workflow_dir = root_path / 'aps_workflows'
    if salt:
        workflow_dir = workflow_dir / salt
    if not _OS.exists(workflow_dir):
        _OS.makedirs(workflow_dir.absolute())
    return workflow_dir


def create_workflow_block_file(
        file_name: str,
        root_path: Path,
        relative_path: str,
        toolbox_version: str,
        use_temporary: Optional[bool] = False,
        salt: Optional[str] = None,
        suffix: str = '',
        use_plugin_dir: bool = False,
) -> None:
    script_name = file_name + '.py'
    script_path = root_path / relative_path / script_name
    assert _OS.exists(script_path), "the file '{}' does not exist".format(script_path)
    if use_plugin_dir:
        workflow_dir = Path('.').absolute() / 'aps_workflows'
        if not _OS.exists(workflow_dir):
            _OS.makedirs(workflow_dir.absolute())
        workflow_path = str(workflow_dir / get_file_mapping(suffix)[script_name])
    else:
        workflow_dir = get_workflow_dir(root_path, use_temporary, salt)
        workflow_path = str(workflow_dir / get_file_mapping(suffix)[script_name])
    workflow_block = get_workflow_block(file_name, relative_path, toolbox_version)
    print(f"Generate: {workflow_path} ")
    with open(workflow_path, 'w', encoding='utf-8') as f:
        f.write(workflow_block)


def get_ipl_scripts(root_path: Path) -> List[Path]:
    ipl_dir = root_path / 'aps/IPL'
    return [ipl_dir / ipl_script for ipl_script in _OS.listdir(ipl_dir)]


def add_ipl_scripts(root_path: Path, project_location: Path) -> None:
    ipl_scripts = get_ipl_scripts(root_path)
    ipl_dir = project_location / 'commandscomp'
    for ipl_script in ipl_scripts:
        _OS.copy(ipl_script.absolute(), ipl_dir.absolute())


def set_file_attributes(root_path: Path) -> None:
    workflow_path = get_workflow_dir(root_path).absolute()
    _set_read_only(workflow_path)


def _set_read_only(workflow_path: Path) -> None:
    _OS.chmod(workflow_path)
    for _, _, files in _OS.walk(workflow_path):
        for file in files:
            _OS.chmod(workflow_path / file)


class _OS:
    @staticmethod
    def walk(path: Path) -> Iterator[Tuple[str, List[str], List[str]]]:
        return os.walk(_OS._get_absolute_path(path))

    @staticmethod
    def copy(source: Path, target: Path) -> None:
        copy(_OS._get_absolute_path(source), _OS._get_absolute_path(target))

    @staticmethod
    def exists(path: Path) -> bool:
        return _OS._exec(path, os.path.exists)

    @staticmethod
    def listdir(path: Path) -> Iterable:
        return _OS._exec(path, os.listdir)

    @staticmethod
    def chmod(path: Path) -> None:
        _OS._exec(path, lambda p: os.chmod(p, 0o555))

    @staticmethod
    def makedirs(path: Path) -> None:
        _OS._exec(path, os.makedirs, kwargs={'exist_ok': True})

    @staticmethod
    def _exec(
            path: Path,
            fun: Callable,
            args: tuple = (),
            kwargs: Optional[dict] = None,
    ) -> Optional[Any]:
        if kwargs is None:
            kwargs = {}
        return fun(_OS._get_absolute_path(path), *args, **kwargs)

    @staticmethod
    def _get_absolute_path(path: Path) -> str:
        return str(path.absolute())


if __name__ == '__main__':
    run()
