#!/usr/bin/env python3
#  -*- coding: utf-8 -*-
"""
A script to create the stubs of Python scripts that will be used in a RMS workflow.
The stubs read the various files from disk (in this repo), so that the various workflows do not need to
be imported whenever there is a change in it, or in one of its dependencies.

This is called when running 'make init', and 'make generate-workflow-files'.

The resulting stubs are given in the 'workflow' directory (which again is inside the root of the repo)

Usage:
    ./bin/generate_workflow_blocks.py [--read-only] [--use-temporary-workflow-dir] [--copy-to-rms-project <path to rms project>]
    ./generate_workflow_blocks.py <path to project folder> [--read-only] [--use-temporary-workflow-dir] [--copy-to-rms-project <path to rms project>]
"""
import random
import string
from pathlib import Path
from shutil import copy
from sys import argv
from tempfile import gettempdir

import os

from src.utils.roxar import get_nrlib_path


def run():
    root_path = get_root_path()
    workflows = get_workflows()
    use_temporary = '--use-temporary-workflow-dir' in argv
    salt = None
    if use_temporary:
        salt = get_random_name()

    for relative_path, items in workflows.items():
        for file_name in items:
            create_workflow_block_file(file_name, root_path, relative_path, use_temporary, salt)

    for i in range(len(argv)):
        arg = argv[i]
        if arg == '--read-only':
            set_file_attributes(root_path)
        elif arg == '--copy-to-rms-project':
            project_location = Path(argv[i + 1]).absolute()
            workflow_dir = get_workflow_dir(root_path, use_temporary, salt)
            add_ipl_scripts(root_path, project_location)
            for rms_name, workflow_name in get_rms_mapping().items():
                if workflow_name is not None:
                    _OS.copy(workflow_dir / rms_name, project_location / 'pythoncomp' / rms_name)


def get_workflow_block(file_name, relative_path):
    template = '''#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
A template for use in RMS workflow.
By using this, the files will be loaded at runtime, and there
is no longer a need to update / import the file into RMS.
This template refers to {relative_path}/{file_name}.py

DO NOT edit this file, unless you know exactly what you are doing!
"""

import roxar.rms

from zipfile import ZipFile
from importlib import import_module
from pathlib import Path

import os
import sys


__author__ = "Sindre Nistad"
__email__ = "snis@equinor.com"
__version__ = "0.8.1"
__status__ = "Draft"

# Toggle whether the source files should be read from the plugin, or the git repo


# Define all used environment variables
APS_ROOT                  = 'APS_ROOT'
APS_RESOURCES             = 'APS_RESOURCES'
APS_MODEL_FILE            = 'APS_MODEL_FILE'
APS_RMS_DATA_FILE         = 'APS_RMS_DATA_FILE'
APS_GLOBAL_INCLUDE_FILE   = 'APS_GLOBAL_INCLUDE_FILE'
APS_FMU_VARIABLES_FILE    = 'APS_FMU_VARIABLES_FILE'
APS_FMU_TAGS_FILE         = 'APS_FMU_TAGS_FILE'
APS_TAG_ALL_VARIABLES     = 'APS_TAG_ALL_VARIABLES'
APS_OUTPUT_FMU_MODEL_FILE = 'APS_OUTPUT_FMU_MODEL_FILE'
APS_WRITE_LOG_FILE        = 'APS_WRITE_LOG_FILE'
APS_INPUT_DIRECTORY       = 'APS_INPUT_DIRECTORY'
APS_DEBUG_LEVEL           = 'APS_DEBUG_LEVEL'


# Utils
def _get_path_from_environment(environment_name, default_name):
    return Path(os.environ.get(environment_name, default_name))


# The path to the repository's root folder
temp_dir = Path(roxar.rms.get_tmp_dir())
root_path = _get_path_from_environment(APS_ROOT, temp_dir / 'aps_gui' / 'pydist')
release_location = Path('/project/res/APSGUI/releases')

# Path to where the file below is located within the repository
relative_path = '{relative_path}'

# Name of Python file to be executed (excluding .py)
file_name = '{file_name}'

# The location of the folder that contains the RMS project
try:
    project_location_path = Path(project.filename).parent
except NameError:
    project_location_path = root_path  # or '.'


def get_plugin_dir():
    major, minor, patch = roxar.rms.get_version().split('.')
    if minor == '0':
        rms_version = major
    else:
        rms_version = major + '.' + minor
    preferences = Path(Path.home() / '.roxar/rms-{{}}/preferences.master'.format(rms_version))
    with open(preferences) as f:
        lines = f.readlines()

    plugin_dir = release_location
    for line in lines:
        if line.startswith('jobplugindir'):
            plugin_dir = Path(line.split('=')[1].strip())
    return plugin_dir


def get_current_plugin_path():
    # TODO: Get the version RMS is _actually_ using
    #       That is, RMS _could_ be using a different version than what is _should_ (this happens occasionally)
    paths = [p.absolute() for p in get_plugin_dir().glob('aps_gui*')]
    paths.sort()
    if len(paths) > 0:
        return paths[-1]
    return None


def stringify_path(path):
    return str(path.absolute())


def extract_plugin():
    extracted = temp_dir / 'aps_gui'

    def unzip():
        with ZipFile(str(get_current_plugin_path())) as zf:
            zf.extractall(path=temp_dir)
    if not extracted.exists():
        unzip()
    else:
        # Check that the version of the extracted plugin is the same as the expected version
        with open(extracted / 'VERSION') as f:
            for line in f.readlines():
                if line:
                    extracted_version = line.strip()
                    break
        if not get_current_plugin_path().match('*' + extracted_version + '*'):
            # A refresh is required
            os.rmdir(extracted)
            unzip()


model_root = _get_path_from_environment(APS_RESOURCES, project_location_path)

if APS_ROOT not in os.environ:
    # Add the path to searchable path
    # Assumed that the plugin should not be used, if 'APS_ROOT' is set
    
    # When a plugin is used, it includes a stump for importing nrlib as well
    extract_plugin()
    sys.path.insert(0, stringify_path(root_path))
else:
    # Add nrlib to PYTHONPATH
    nrlib_path = Path('{nrlib_path}')
    if nrlib_path.exists():
        sys.path.insert(0, stringify_path(nrlib_path))


# Generating necessary paths
def _load_module():
    module_path = relative_path.replace('/', '.') + '.' + file_name
    try:
        return import_module(module_path)
    except ModuleNotFoundError:
        return import_module(module_path.replace('src', 'aps'))


# Getting the location of the necessary files
def _get_file(environ_name, default_name):
    return _get_path_from_environment(environ_name, prepend_absolute_path(default_name))


def _get_value(environ_name, default_value):
    return os.environ.get(environ_name, default_value)


def _undefined_file():
    return '_APS_NO_FILE'


def get_model_file():
    # Location of misc. specification files;
    # * APS.xml
    # * Create_redefined_blocked_facies_log.xml
    # * Create_prob_logs.xml
    # * bitmap2rms_model.xml
    path = _get_file(APS_MODEL_FILE, _undefined_file())
    if str(path).endswith(_undefined_file()):
        return None
    else:
        return path


def get_rms_data_file():
    # Location/name of rms_project_data_for_APS_gui.xml
    return _get_file(APS_RMS_DATA_FILE, 'rms_project_data_for_APS_gui.xml')


def get_global_include_file():
    # Location/name of test_global_include.ipl
    # TODO: Migrate to yml
    return _get_file(APS_GLOBAL_INCLUDE_FILE, 'test_global_include.ipl')


def get_fmu_variables_file():
    return _get_file(APS_FMU_VARIABLES_FILE, 'examples/FMU_selected_variables.dat')


def get_tagged_variables_file():
    return _get_file(APS_FMU_TAGS_FILE, 'examples/FMU_tagged_variables.dat')


def get_tag_all_variables():
    return _get_value(APS_TAG_ALL_VARIABLES, False)


def get_output_fmu_tagged_model_file():
    return _get_file(APS_OUTPUT_FMU_MODEL_FILE, 'APS_with_FMU_tags.xml')


def get_write_logfile():
    return _get_value(APS_WRITE_LOG_FILE, True)


def get_input_directory():
    path = Path(os.environ.get(APS_INPUT_DIRECTORY, 'tmp_gauss_sim'))
    if not path.is_absolute():
        path = model_root / path
    return path


def get_debug_level():
    # How verbose it should be
    return _get_value(APS_DEBUG_LEVEL, 0)


def prepend_absolute_path(file):
    return model_root / file


# Keywords to pass along to the various modules
kwargs = {{
    # Legal values: 0..4 (0 is off, while 4 is very verbose)
    'debug_level': get_debug_level(),
    # Misc. flags
    'use_prefix_as_fallback': True,
    'write_log_file': get_write_logfile(),
    # Prefix for the location of model files (if absolute paths are not given)
    'prefix': root_path,
    # APS model file
    'model_file_name': get_model_file(),
    'output_rms_data_file': get_rms_data_file(),
    'global_ipl_file': get_global_include_file(),
    'output_model_file': get_output_fmu_tagged_model_file(),
    # FMU parameters
    'tagged_variables_file': get_tagged_variables_file(),
    'tag_all_variables': get_tag_all_variables(),
    'fmu_variables_file': get_fmu_variables_file(),
    'input_directory': get_input_directory(),
}}

# Stringify Paths
for key, value in kwargs.items():
    if isinstance(value, Path):
        kwargs[key] = stringify_path(value)

module = _load_module()
module.run(roxar, project, **kwargs)
'''

    return template.format(
        file_name=file_name,
        relative_path=relative_path,
        nrlib_path=get_nrlib_path(),
    )


def get_root_path():
    if len(argv) == 1 or argv[1] in ['--read-only',  '--copy-to-rms-project', '--use-temporary-workflow-dir']:
        return Path('.').absolute()
    else:
        return Path(argv[1])


def get_workflows():
    return {
        'bin': [
        ],
        'depricated': [
        ],
        'src/rms_jobs': [
            'APS_main',
            'APS_simulate_gauss_multiprocessing',
            'APS_simulate_gauss_singleprocessing',
            'defineFaciesProbMapDepTrend',
            'defineFaciesProbTrend',
            'APS_normalize_prob_cubes',
            'APS_set_seed_file_for_multiprocessing_workflow',
            'bitmap2rms',
            'Compare_files_with_uncertainty_parameters',
            'updateAPSModelFromFMU',
            'updateAPSModelFromUncertaintyTable',
            'createProbabilityLogs',
            'createRedefinedBlockedFaciesLog',
        ],
        'src/algorithms': [
            'setupFMUtags',
        ],
        'src/utils': [
            'testPreview',
        ],
        'src/utils/roxar': [
            'APS_update_gauss_rms',
            'getGridModelAttributes',
            'compare_files',
        ],
    }


def get_rms_mapping():
    return {
        'APS_truncate': 'APS_main.py',
        'Test_APS': None,
        'APS_test_preview': 'testPreview.py',
        'APS_update_from_FMU': 'updateAPSModelFromFMU.py',
        'APS_define_depositional_trend': 'defineFaciesProbMapDepTrend.py',
        'APS_simulate_gauss_fields_multiprocessing': 'APS_simulate_gauss_multiprocessing.py',
        'APS_import_simulated_gauss_fields': 'APS_update_gauss_rms.py',
        'APS_simulate_gauss_fields': 'APS_simulate_gauss_singleprocessing.py',
        'APS_export_grid_model_info': 'getGridModelAttributes.py',
        'test_welldata_api': None,
        'test_gridmodel_parameters_api': None,
        'Example_discrete_parameter_info': None,
        'Example_zone_and_region_parameter': None,
        'APS_update_from_rms_uncertainty_table': 'updateAPSModelFromUncertaintyTable.py',
        'Compare_files_with_uncertainty_parameters': 'Compare_files_with_uncertainty_parameters.py',
        'APS_define_probability_logs': 'createProbabilityLogs.py',
        'APS_merge_facies_logs': 'createRedefinedBlockedFaciesLog.py',
        'APS_create_FMU_tags': 'setupFMUtags.py',
        'APS_define_probability_trends': 'defineFaciesProbTrend.py',
        'Compare_files_updated_with_FMU_parameters': None,
        'APS_normalize_prob_cubes': 'APS_normalize_prob_cubes.py',
        'APS_bitmap2rms': 'bitmap2rms.py',
        'APS_set_seed_file_for_multiprocessing_workflow': 'APS_set_seed_file_for_multiprocessing_workflow.py',
        'APS_compare_files': 'compare_files.py',
    }


def get_random_name(length=5):
    characters = string.ascii_letters + string.digits
    return ''.join([random.choice(characters) for _ in range(length)])


def get_file_mapping():
    return {file: rms_name for rms_name, file in get_rms_mapping().items() if file}


def get_workflow_dir(root_path, use_temporary=False, salt=None):
    if use_temporary:
        root_path = Path(gettempdir())
    workflow_dir = root_path / 'aps_workflows'
    if salt:
        workflow_dir = workflow_dir / salt
    if not _OS.exists(workflow_dir):
        _OS.makedirs(workflow_dir.absolute())
    return workflow_dir


def create_workflow_block_file(file_name, root_path, relative_path, use_temporary=False, salt=None):
    script_name = file_name + '.py'
    script_path = root_path / relative_path / script_name
    assert _OS.exists(script_path), "the file '{}' does not exist".format(script_path)
    workflow_dir = get_workflow_dir(root_path, use_temporary, salt)
    workflow_path = str(workflow_dir / get_file_mapping()[script_name])
    workflow_block = get_workflow_block(file_name, relative_path)
    with open(workflow_path, 'w') as f:
        f.write(workflow_block)


def get_ipl_scripts(root_path):
    ipl_dir = root_path / 'src/IPL'
    return [ipl_dir / ipl_script for ipl_script in _OS.listdir(ipl_dir)]


def add_ipl_scripts(root_path, project_location):
    ipl_scripts = get_ipl_scripts(root_path)
    ipl_dir = project_location / 'commandscomp'
    for ipl_script in ipl_scripts:
        _OS.copy(ipl_script.absolute(), ipl_dir.absolute())


def set_file_attributes(root_path):
    workflow_path = get_workflow_dir(root_path).absolute()
    _set_read_only(workflow_path)


def _set_read_only(workflow_path):
    _OS.chmod(workflow_path)
    for _, _, files in _OS.walk(workflow_path):
        for file in files:
            _OS.chmod(workflow_path / file)


class _OS:
    @staticmethod
    def walk(path):
        return os.walk(_OS._get_absolute_path(path))

    @staticmethod
    def copy(source, target):
        copy(_OS._get_absolute_path(source), _OS._get_absolute_path(target))

    @staticmethod
    def exists(path):
        return _OS._exec(path, os.path.exists)

    @staticmethod
    def listdir(path):
        return _OS._exec(path, os.listdir)

    @staticmethod
    def chmod(path):
        _OS._exec(path, lambda p: os.chmod(p, 0o555))

    @staticmethod
    def makedirs(path):
        _OS._exec(path, os.makedirs)

    @staticmethod
    def _exec(path, fun):
        return fun(_OS._get_absolute_path(path))

    @staticmethod
    def _get_absolute_path(path):
        return str(path.absolute())


if __name__ == '__main__':
    run()
