from numpy import (
    float32,
    float64,
    ndarray,
)
from src.algorithms.APSMainFaciesTable import APSMainFaciesTable
from typing import (
    List,
    Optional,
    Tuple,
    Union,
    Sized,
)
from xml.etree.ElementTree import Element

from src.utils.constants.simple import Debug


class Trunc2D_Base:
    num_facies_in_zone: int
    num_global_facies: int
    num_facies_in_truncation_rule: int
    def __init__(
        self,
        trRuleXML: Optional[Element] = None,
        mainFaciesTable: Optional[APSMainFaciesTable] = None,
        faciesInZone: Optional[List[str]] = None,
        gaussFieldsInZone: Optional[List[str]] = None,
        debug_level: Debug = Debug.OFF,
        modelFileName: Optional[str] = None,
        nGaussFieldsInBackGroundModel: int = 2
    ) -> None: ...
    def __repr__(self) -> str: ...
    def _setEmpty(self): ...
    def _XMLAddElement(self, parent: Element) -> None: ...
    def _addFaciesToTruncRule(self, facies_name: str) -> Tuple[int, int, int, int]: ...
    def _checkFaciesForZone(self) -> None: ...
    def _interpretXMLTree_overlay_facies(
        self,
        trRuleXML: Element,
        modelFileName: str,
        zoneNumber: Optional[int]
    ) -> None: ...
    def _isFaciesProbEqualOne(self, faciesProb: List[float]) -> bool: ...
    @staticmethod
    def _isInsidePolygon(
        polygon: Union[List[List[float]], List[Union[List[int], List[float64]]]],
        xInput: Union[float32, float64],
        yInput: Union[float32, float64]
    ) -> bool: ...
    @staticmethod
    def _makeKey(faciesProb: List[float], keyResolution: int) -> Tuple[float, ...]: ...
    @staticmethod
    def _makeRoundOfFaciesProb(faciesProb: List[float], keyResolution: int) -> List[float]: ...
    def _modifyBackgroundFaciesArea(self, faciesProb: List[float]) -> ndarray: ...
    @staticmethod
    def _length_of_property(prop: Optional[Sized]) -> int: ...
    def _setEmpty(self) -> None: ...
    def _setGaussFieldForBackgroundFaciesTruncationMap(
        self,
        gaussFieldsInZone: List[str],
        alphaFieldNameForBackGroundFacies: List[str],
        nGaussFieldsInBackGroundModel: int
    ) -> None: ...
    def _setModelledFacies(
        self,
        mainFaciesTable: APSMainFaciesTable,
        faciesInZone: List[str]
    ) -> None: ...
    def _setOverlayFaciesDataStructure(
        self,
        overlayGroups: Optional[List[List[Union[List[List[Union[str, float]]], List[str]]]]]
    ) -> None: ...
    def _truncateOverlayFacies(self, indx: int, alphaCoord: ndarray) -> Tuple[int, int]: ...
    def defineFaciesByTruncRule(self, alphaCoord): ...
    def getGaussFieldsInTruncationRule(self): ...
    def getAlphaIndexInZone(self, alphaName: str) -> int: ...
    def getBackgroundFaciesInTruncRuleIndex(self, fName: str) -> int: ...
    def getEpsFaciesProb(self) -> float: ...
    def setEpsFaciesProb(self, eps): ...
    def getFaciesInTruncRule(self) -> List[str]: ...
    def getFaciesInTruncRuleIndex(self, fName: str) -> int: ...
    def getFaciesInZoneIndex(self, facies_name: str) -> int: ...
    def getFaciesOrderIndexList(self) -> List[int]: ...
    def getGaussFieldIndexListInZone(self) -> List[int]: ...
    def getNGaussFieldsInModel(self) -> int: ...
    def getKeyResolution(self): ...
    def getNLookupTruncMap(self): ...
    def getNCalcTruncMap(self): ...
    def getClassName(self): ...
    def writeContentsInDataStructure(self): ...
    def _setMinimumFaciesProb(self, faciesProb): ...
    def __addAlpha(self, alphaName: str, createErrorIfExist: bool = False) -> None: ...
    def __interpretXMLTree_read_gauss_field_names(self, trRuleXML, gaussFieldsInZone, modelFileName): ...
    def __isFaciesInZone(self, fName): ...
    def __calcGroupIndxForBGFacies(self): ...
    def __checkCenterTruncInterval(self): ...
    def __checkProbFrac(self): ...
    def __checkAlphaIndx(self): ...
    def __checkOverlayFacies(self): ...
